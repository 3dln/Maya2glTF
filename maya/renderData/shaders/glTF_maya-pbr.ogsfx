uniform mat4 gWVPXf : WorldViewProjection;
uniform mat4 gWXf : World;
uniform mat4 gVIXf : ViewInverse;

// -------------------------------------------------------------

uniform int Light0Type : LIGHTTYPE
<
	string UIName = "Light 0 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object = "Light 0";
> = 3;

uniform int Light1Type : LIGHTTYPE
<
	string UIName = "Light 1 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object = "Light 1";
> = 3;

uniform vec3 Light0Color : LIGHTCOLOR
<
	string UIName = "Light 0 Color";
	string UIWidget = "ColorPicker";
	string Object = "Light 0";
> = {1.0, 1.0, 1.0};

uniform vec3 Light1Color : LIGHTCOLOR
<
	string UIName = "Light 1 Color";
	string UIWidget = "ColorPicker";
	string Object = "Light 1";
> = {1.0, 1.0, 1.0};

uniform vec3 Light0Pos : POSITION
<
	string UIName = "Light 0 Position";
	string Space = "World";
	string Object = "Light 0";
> = {1.0, 1.0, 1.0};

uniform vec3 Light1Pos : POSITION
<
	string UIName = "Light 1 Position";
	string Space = "World";
	string Object = "Light 1";
> = {1.0, 1.0, 1.0};

uniform vec3 Light0Dir : DIRECTION
<
	string UIName = "Light 0 Direction";
	string Space = "World";
	string Object = "Light 0";
> = {0.0, -1.0, 0.0};

uniform vec3 Light1Dir : DIRECTION
<
	string UIName = "Light 1 Direction";
	string Space = "World";
	string Object = "Light 1";
> = {0.0, -1.0, 0.0};

uniform float Light0Intensity : LIGHTINTENSITY
<
	string UIName = "Light 0 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object = "Light 0";
> = 1.0;

uniform float Light1Intensity : LIGHTINTENSITY
<
	string UIName = "Light 1 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object = "Light 1";
> = 1.0;

uniform float Light0Attenuation : DECAYRATE
<
	string UIName = "Light 0 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object = "Light 0";
> = 0.0;

uniform float Light1Attenuation : DECAYRATE
<
	string UIName = "Light 1 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object = "Light 1";
> = 0.0;

uniform float Light0ConeAngle : HOTSPOT
<
	string UIName = "Light 0 Cone Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object = "Light 0";
> = 0.46;

uniform float Light1ConeAngle : HOTSPOT
<
	string UIName = "Light 1 Cone Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object = "Light 1";
> = 0.46;

uniform float Light0Falloff : FALLOFF
<
	string UIName = "Light 0 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object = "Light 0";
> = 0.7;

uniform float Light1Falloff : FALLOFF
<
	string UIName = "Light 1 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object = "Light 1";
> = 0.7;

uniform vec4 gBaseColorFactor : DIFFUSE
<
  string UIName = "Base Color Factor";
	string UIGroup = "PBR Material";
> = {1.0, 1.0, 1.0, 1.0};

uniform texture2D gBaseColorTexture
<
  string UIName = "Base Color Map";
  string ResourceType = "2D";
	string UIGroup = "PBR Material";
>;

uniform sampler2D gBaseColorSampler = sampler_state
{
  Texture = <gBaseColorTexture>;
};

uniform float gMetallicStrength
<
  string UIName = "Metallic strength";
	string UIGroup = "PBR Material";
> = 1;

uniform float gRoughnessStrength
<
  string UIName = "Roughness strength";
	string UIGroup = "PBR Material";
> = 1;

uniform float gOcclusionStrength
<
  string UIName = "Occlusion strength";
	string UIGroup = "PBR Material";
> = 0;

uniform texture2D gOcclusionMetallicRoughnessTexture
<
  string UIName = "AO Ro Me (RGB) map";
  string ResourceType = "2D";
	string UIGroup = "PBR Material";
>;

uniform sampler2D gOcclusionMetallicRoughnessSampler = sampler_state
{
  Texture = <gOcclusionMetallicRoughnessTexture>;
};

uniform float gNormalScale
<
  string UIName = "Normal Scale";
	string UIGroup = "PBR Material";
>;

uniform texture2D gNormalTexture
<
  string UIName = "Normal Map";
  string ResourceType = "2D";
	string UIGroup = "PBR Material";
>;

uniform sampler2D gNormalSampler = sampler_state
{
  Texture = <gNormalTexture>;
};

uniform texture2D gBrdfLUT
<
  string UIName = "BRDF LUT";
  string ResourceType = "2D";
	string UIGroup = "PBR Material";
>;

uniform sampler2D gBrdfLUTSampler = sampler_state
{
  Texture = <gBrdfLUT>;
  TEXTURE_MIN_FILTER = LINEAR;
	TEXTURE_MAG_FILTER = LINEAR;
	TEXTURE_WRAP_S = CLAMP_TO_EDGE;
	TEXTURE_WRAP_T = CLAMP_TO_EDGE;
	TEXTURE_WRAP_R = CLAMP_TO_EDGE;  
};

uniform textureCube gDiffuseEnvTexture
<
  string UIName = "Diffuse env map";
  string ResourceType = "Cube";
	string UIGroup = "PBR Material";
>;

uniform samplerCube gDiffuseEnvSampler = sampler_state
{
  Texture = <gDiffuseEnvTexture>;
};

uniform textureCube gSpecularEnvTexture
<
  string UIName = "Specular env map";
  string ResourceType = "Cube";
	string UIGroup = "PBR Material";
>;

uniform samplerCube gSpecularEnvSampler = sampler_state
{
  Texture = <gSpecularEnvTexture>;
};

uniform float gEmissiveFactor
<
  string UIName = "Emissive Factor";
	string UIGroup = "PBR Material";
> = 1;

uniform texture2D gEmissiveTexture
<
  string UIName = "Emissive Map";
  string ResourceType = "2D";
	string UIGroup = "PBR Material";
>;

uniform sampler2D gEmissiveSampler = sampler_state
{
  Texture = <gEmissiveTexture>;
};

struct PBRInfo
{
  float NdotV;
  float perceptualRoughness;
  float metalness;
  float alphaRoughness;
  vec3 diffuseColor;
  vec3 specularColor;
};

struct LightInfo
{
  float NdotL;
  float NdotH;
  float LdotH;
  float VdotH;
  vec3 reflectance0;
  vec3 reflectance90;
};

// -------------------------------------------------------------

attribute vs_input
{
  vec4 in_position : POSITION;
  vec4 in_normal : NORMAL;
  vec4 in_tangent : TANGENT;
  vec2 in_texcoord : TEXCOORD0;
};

attribute vs_to_ps
{
  vec3 v_position;
  mat3 v_tbn;
  vec2 v_texcoord;
};

attribute ps_output 
{
  vec4 out_color : COLOR0;
}

// -------------------------------------------------------------

GLSLShader VS
{
  void main() 
  {
    // vec4 pos = gWXf * in_position;
    // v_position = vec3(in_position.xyz) / pos.w;
    v_position = (gWXf * in_position).xyz;

    vec3 normalW = normalize(vec3(gWXf * vec4(in_normal.xyz, 0.0)));
    vec3 tangentW = normalize(vec3(gWXf * vec4(in_tangent.xyz, 0.0)));
    vec3 bitangentW = cross(normalW, tangentW) * in_tangent.w;
    v_tbn = mat3(tangentW, bitangentW, normalW);

    v_texcoord = vec2(in_texcoord.x, 1.0 - in_texcoord.y);

    gl_Position = gWVPXf * in_position;
  }
}

GLSLShader PS
{
  const float cMinRoughness = 0.04;
  const float cPi = 3.141592653589793;
  const float MAX_LIGHTS = 4;

  vec4 SRGBtoLINEAR(vec4 srgbIn)
  {
    /*
    vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
    vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess);
    return vec4(linOut, srgbIn.w);
    */
    return srgbIn;
  }

  vec3 specularReflection(LightInfo lightInfo)
  {
    return lightInfo.reflectance0 + (lightInfo.reflectance90 - lightInfo.reflectance0) * pow(clamp(1.0 - lightInfo.VdotH, 0.0, 1.0), 5.0);
  }

  float geometricOcclusion(float NdotL, float NdotV, float alphaRoughness)
  {
    float r = alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
  }

  float microfacetDistribution(float NdotH, float alphaRoughness)
  {
    float roughnessSq = alphaRoughness * alphaRoughness;
    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;
    return roughnessSq / (cPi * f * f);
  }

  vec3 diffuse(PBRInfo pbrInputs)
  {
    return pbrInputs.diffuseColor / cPi;
  }

  vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
  {
    float mipCount = 9.0; // resolution of 512x512
    float lod = (pbrInputs.perceptualRoughness * mipCount);

    vec3 brdf = SRGBtoLINEAR(texture2D(gBrdfLUTSampler, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
    vec3 diffuseLight = SRGBtoLINEAR(textureCube(gDiffuseEnvSampler, n)).rgb;

    vec3 specularLight = SRGBtoLINEAR(textureLod(gSpecularEnvSampler, reflection, lod)).rgb;

    vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
    vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);

    return diffuse + specular;
  }

  void main()
  {
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 ormSample = texture2D(gOcclusionMetallicRoughnessSampler, v_texcoord);

    float metallic = clamp(gMetallicStrength * ormSample.b, 0.0, 1.0);
    float perceptualRoughness = clamp(gRoughnessStrength * ormSample.g, cMinRoughness, 1.0);

    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec4 baseColor = SRGBtoLINEAR(texture2D(gBaseColorSampler, v_texcoord)) * gBaseColorFactor;

    vec3 f0 = vec3(.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0) * reflectance90;

    vec3 tn = texture2D(gNormalSampler, v_texcoord).rgb;
    vec3 n = normalize(v_tbn * ((2.0 * tn - 1.0) * vec3(gNormalScale, gNormalScale, 1.0)));
    vec3 v = normalize(gVIXf[3].xyz - v_position);
    vec3 reflection = -normalize(reflect(v, n));

    float NdotV = abs(dot(n, v)) + 0.001;

    PBRInfo pbrInputs = PBRInfo(
      NdotV,
      perceptualRoughness,
      metallic,
      alphaRoughness,
      diffuseColor,
      specularColor
    );

    vec3 color = vec3(0.0);

    for (int i = 0; i < MAX_LIGHTS; ++i)
    {
      vec3 vec2light;
      vec3 l;
      float lum;
      float intensity;
      vec3 lightColor;
      if (i == 0) {
        vec2light = Light0Pos.xyz - /*(Light0Pos.w * */v_position.xyz/*)*/;
        if (Light0Type == 4) { // directional light
          l = normalize(-Light0Dir);
          lum = 1;
        } else {
          l = normalize(vec2light);
          lum = 1.0 / pow(length(vec2light), Light0Attenuation);
          if (Light0Type == 2) { // spot light
            float CosOp = cos(max(Light0Falloff, Light0ConeAngle));
            float DotOp = dot(l, -(Light0Dir));
            lum *= smoothstep(CosOp, cos(Light0ConeAngle), DotOp);
          }
        }
        intensity = Light0Intensity;
        lightColor = Light0Color;
      } else {
        vec2light = Light1Pos.xyz - /*(Light0Pos.w * */v_position.xyz/*)*/;
        if (Light1Type == 4) { // directional light
          l = normalize(-Light1Dir);
          lum = 1;
        } else {
          l = normalize(vec2light);
          lum = 1.0 / pow(length(vec2light), Light1Attenuation);
          if (Light1Type == 2) { // spot light
            float CosOp = cos(max(Light1Falloff, Light1ConeAngle));
            float DotOp = dot(l, -(Light1Dir));
            lum *= smoothstep(CosOp, cos(Light1ConeAngle), DotOp);
          }
        }
        intensity = Light1Intensity;
        lightColor = Light1Color;
      }
      //vec3 l = normalize(-gLightDirection[i]);
      vec3 h = normalize(l + v);

      float NdotL = clamp(dot(n, l), 0.001, 1.0);
      float NdotH = clamp(dot(n, h), 0.0, 1.0);
      float LdotH = clamp(dot(l, h), 0.0, 1.0);
      float VdotH = clamp(dot(v, h), 0.0, 1.0);

      LightInfo lightInputs = LightInfo(
        NdotL,
        NdotH,
        LdotH,
        VdotH,
        specularEnvironmentR0,
        specularEnvironmentR90
      );

      vec3 F = specularReflection(lightInputs);
      float G = geometricOcclusion(NdotL, NdotV, alphaRoughness);
      float D = microfacetDistribution(NdotH, alphaRoughness);

      vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
      vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
      color += NdotL * lightColor * (diffuseContrib + specContrib) * lum * intensity;
    }

    color += getIBLContribution(pbrInputs, n, reflection);

    color = mix(color, color * ormSample.r, gOcclusionStrength);

    vec3 emissive = SRGBtoLINEAR(texture2D(gEmissiveSampler, v_texcoord)).rgb * gEmissiveFactor;
    color += emissive;

    // We assume you perform linear -> sRGB or whatever output colorspace in Maya
    out_color = vec4(color, baseColor.a);
  }
}
 
technique Main
{
  pass p0
  {
    VertexShader (in vs_input, out vs_to_ps) = VS;
    PixelShader (in vs_to_ps, out ps_output) = PS;
  }
}